<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D FPS Game</title>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            background: rgb(90, 2, 2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            transition: width 0.1s, height 0.1s;
        }
        #score {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
            color: white;
            font-family: Arial, sans-serif;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        #healthBarBackground {
            position: absolute;
            top: 50px;
            left: 10px;
            width: 200px;
            height: 20px;
            background-color: #555;
            border-radius: 10px;
            border: 2px solid #333;
        }

        #healthBar {
            height: 100%;
            width: 100%; /* Initially 100% width */
            background-color: rgb(90, 2, 2);
            border-radius: 8px;
        }
        #gameOverMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 48px;
            color: white;
            font-family: Arial, sans-serif;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            transform: translate(-50%, -50%);
            display: none;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="score">Score: 0</div>
    <div id="gameOverMessage">GAME OVER</div>
    <div id="healthBarBackground">
        <div id="healthBar"></div>
    </div>


    <script>
        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 5);
        scene.add(light);

        // Add fog to the scene
        scene.fog = new THREE.Fog(0xaaaaaa, 1, 40);  // Color, start distance, end distance

        // Load Skybox (replace with path to your own skybox images)
        const loader = new THREE.CubeTextureLoader();

        // Load the skybox textures
        const skybox = loader.load([
            '/assets/sky/interstellar_lf.jpg',   // Left
            '/assets/sky/interstellar_rt.jpg',   // Right
            '/assets/sky/interstellar_up.jpg',   // Up
            '/assets/sky/interstellar_dn.jpg',   // 4
            '/assets/sky/interstellar_ft.jpg',   // Front
            '/assets/sky/interstellar_bk.jpg'   // Back
        ], function (textures) {
            // Set the background of the scene to the skybox
            scene.background = new THREE.CubeTexture(textures);
        });

        // Load Tree Model using GLTFLoader
        const gltfLoader = new THREE.GLTFLoader();

        function loadTree(x, z) {
            gltfLoader.load('/assets/floor/Tree1.gltf', (gltf) => {
                const tree = gltf.scene;
                tree.scale.set(2, 2, 2); // Adjust the scale of the tree model
                tree.position.set(x, 0, z);
                scene.add(tree);
            });
        }

        // Create multiple trees
        for (let i = 0; i < 10; i++) {
            loadTree((Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30);
        }

        // Add a dark floor suitable for a horror game
        const floorGeometry = new THREE.PlaneGeometry(100, 100);  // 100x100 size
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,  // Dark grey color for a horror-like atmosphere
            roughness: 0.9,    // High roughness for a more matte, uneven look
            metalness: 0.1     // Low metalness to keep it non-reflective
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;  // Rotate to make the floor flat
        scene.add(floor);

        // Player movement variables
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let targetRotationX = 0, targetRotationY = 0;
        let score = 0, health = 100;
        const mouseSensitivity = 0.002;
        const playerSpeed = 0.1;

        // Targets array
        const targets = [];
        const targetGeometry = new THREE.BoxGeometry(1, 1, 1);
        const targetMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

        // Create targets
        function createTarget() {
            const target = new THREE.Mesh(targetGeometry, targetMaterial);
            target.position.set((Math.random() - 0.5) * 20, 1, (Math.random() - 0.5) * 20);
            target.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.1,
                0,
                (Math.random() - 0.5) * 0.1
            );
            scene.add(target);
            targets.push(target);
        }

        // Create initial targets
        for (let i = 0; i < 5; i++) {
            createTarget();
        }

        // Health bar update
        function updateHealthBar() {
            const healthBar = document.getElementById('healthBar');
            healthBar.style.width = `${health}%`;
        }

        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveLeft = true; break;
                case 'KeyA': moveRight = true; break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveLeft = false; break;
                case 'KeyA': moveRight = false; break;
            }
        });

        // Mouse look event
        let isPointerLocked = false;
        document.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                targetRotationY -= e.movementX * mouseSensitivity; // Yaw (left/right)
                targetRotationX -= e.movementY * mouseSensitivity; // Pitch (up/down)
                targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX)); // Limit vertical rotation
            }
        });

        // Handle mouse click (shoot)
        document.addEventListener('click', () => {
            if (!isPointerLocked) {
                renderer.domElement.requestPointerLock();
                isPointerLocked = true;
                return;
            }

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            const intersects = raycaster.intersectObjects(targets);
            if (intersects.length > 0) {
                const target = intersects[0].object;
                scene.remove(target);
                targets.splice(targets.indexOf(target), 1);
                score++;
                health = Math.min(100, health + 2);  // Regain a small amount of health
                updateHealthBar();
                console.log(`Score: ${score} | Health: ${health}`);
                createTarget();
            }
        });

        // Pointer lock change event
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement !== renderer.domElement) {
                isPointerLocked = false;
                console.log("Pointer Lock Released");
            }
        });

        // Set up camera position
        camera.position.set(0, 2, 5);

        // Health decrease logic over time
        let lastHitTime = Date.now();
        function decreaseHealthOverTime() {
            if (Date.now() - lastHitTime > 5000) { // 5 seconds without hitting a target
                health -= 0.1; // Gradually decrease health
                updateHealthBar();
            }

            if (health <= 0) {
                document.getElementById('gameOverMessage').style.display = 'block'; // Show "Game Over" message
                return true; // Game over
            }

            return false;
        }

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            if (decreaseHealthOverTime()) return;

            // Update target positions (moving them)
            targets.forEach(target => {
                target.position.add(target.velocity);
                // Bounce off the ground
                if (target.position.x > 20 || target.position.x < -20) target.velocity.x *= -1;
                if (target.position.z > 20 || target.position.z < -20) target.velocity.z *= -1;
            });

            // Smooth camera rotation (lerp between target rotation and current rotation)
            camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.1;
            camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.1;

            // Player movement
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;  // Remove vertical component
            direction.normalize();  // Normalize the direction to avoid scaling issues

            // Moving forward/backward
            if (moveForward) camera.position.addScaledVector(direction, playerSpeed);
            if (moveBackward) camera.position.addScaledVector(direction, -playerSpeed);

            // Moving left/right
            const right = new THREE.Vector3();
            right.crossVectors(new THREE.Vector3(0, 1, 0), direction).normalize(); // Get right vector

            if (moveLeft) camera.position.addScaledVector(right, -playerSpeed);
            if (moveRight) camera.position.addScaledVector(right, playerSpeed);

            // Render the scene
            renderer.render(scene, camera);
        }

        animate();
    </script>

    <!-- <script>
        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 5);
        scene.add(light);

        // Add fog to the scene
        scene.fog = new THREE.Fog(0xaaaaaa, 1, 40);  // Color, start distance, end distance

        // Load Skybox (replace with path to your own skybox images)
        const loader = new THREE.CubeTextureLoader();

        // Load the skybox textures
        const skybox = loader.load([
            '/assets/sky/interstellar_lf.jpg',   // Left
            '/assets/sky/interstellar_rt.jpg',   // Right
            '/assets/sky/interstellar_up.jpg',   // Up
            '/assets/sky/interstellar_dn.jpg',   // 4
            '/assets/sky/interstellar_ft.jpg',   // Front
            '/assets/sky/interstellar_bk.jpg'   // Back
        ], function (textures) {
            // Set the background of the scene to the skybox
            scene.background = new THREE.CubeTexture(textures);
        });

        // Load Tree Model using GLTFLoader
        const gltfLoader = new THREE.GLTFLoader();

        function loadTree(x, z) {
            gltfLoader.load('/assets/floor/Tree1.gltf', (gltf) => {
                const tree = gltf.scene;
                tree.scale.set(2, 2, 2); // Adjust the scale of the tree model
                tree.position.set(x, 0, z);
                scene.add(tree);
            });
        }

        // Create multiple trees
        for (let i = 0; i < 10; i++) {
            loadTree((Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30);
        }

        // Add a dark floor suitable for a horror game
        const floorGeometry = new THREE.PlaneGeometry(100, 100);  // 100x100 size
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,  // Dark grey color for a horror-like atmosphere
            roughness: 0.9,    // High roughness for a more matte, uneven look
            metalness: 0.1     // Low metalness to keep it non-reflective
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;  // Rotate to make the floor flat
        scene.add(floor);

        // Player movement variables
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let targetRotationX = 0, targetRotationY = 0;
        let score = 0, health = 100;
        const mouseSensitivity = 0.002;
        const playerSpeed = 0.1;

        // Targets array
        const targets = [];
        const targetGeometry = new THREE.BoxGeometry(1, 1, 1);
        const targetMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

        // Create targets
        function createTarget() {
            const target = new THREE.Mesh(targetGeometry, targetMaterial);
            target.position.set((Math.random() - 0.5) * 20, 1, (Math.random() - 0.5) * 20);
            target.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.1,
                0,
                (Math.random() - 0.5) * 0.1
            );
            scene.add(target);
            targets.push(target);
        }

        // Create initial targets
        for (let i = 0; i < 5; i++) {
            createTarget();
        }

        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveLeft = true; break;
                case 'KeyA': moveRight = true; break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveLeft = false; break;
                case 'KeyA': moveRight = false; break;
            }
        });

        // Mouse look event
        let isPointerLocked = false;
        document.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                targetRotationY -= e.movementX * mouseSensitivity; // Yaw (left/right)
                targetRotationX -= e.movementY * mouseSensitivity; // Pitch (up/down)
                targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX)); // Limit vertical rotation
            }
        });

        // Handle mouse click (shoot)
        document.addEventListener('click', () => {
            if (!isPointerLocked) {
                renderer.domElement.requestPointerLock();
                isPointerLocked = true;
                return;
            }

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            const intersects = raycaster.intersectObjects(targets);
            if (intersects.length > 0) {
                const target = intersects[0].object;
                scene.remove(target);
                targets.splice(targets.indexOf(target), 1);
                score++;  // Increase the score when a target is hit
                document.getElementById("score").innerText = `Score: ${score}`;  // Update score on screen
                createTarget();
            }
        });

        // Pointer lock change event
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement !== renderer.domElement) {
                isPointerLocked = false;
                console.log("Pointer Lock Released");
            }
        });

        // Set up camera position
        camera.position.set(0, 2, 5);

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            // Update target positions (moving them)
            targets.forEach(target => {
                target.position.add(target.velocity);
                // Bounce off the ground
                if (target.position.x > 20 || target.position.x < -20) target.velocity.x *= -1;
                if (target.position.z > 20 || target.position.z < -20) target.velocity.z *= -1;
            });

            // Smooth camera rotation (lerp between target rotation and current rotation)
            camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.1;
            camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.1;

            // Player movement
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;  // Remove vertical component
            direction.normalize();  // Normalize the direction to avoid scaling issues

            // Moving forward/backward
            if (moveForward) camera.position.addScaledVector(direction, playerSpeed);
            if (moveBackward) camera.position.addScaledVector(direction, -playerSpeed);

            // Moving left/right
            const right = new THREE.Vector3();
            right.crossVectors(new THREE.Vector3(0, 1, 0), direction).normalize(); // Get right vector

            if (moveLeft) camera.position.addScaledVector(right, -playerSpeed);
            if (moveRight) camera.position.addScaledVector(right, playerSpeed);

            // Render the scene
            renderer.render(scene, camera);
        }

        animate();
    </script> -->

</body>
</html>
