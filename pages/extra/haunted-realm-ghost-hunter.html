<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Haunted Realm: Ghost Hunter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/audio/AudioListener.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/audio/PositionalAudio.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000;
            font-family: 'Arial', sans-serif;
            cursor: none;
            touch-action: none;
        }
        canvas { 
            display: block; 
            outline: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30"><circle cx="15" cy="15" r="12" fill="none" stroke="rgba(255,255,255,0.8)" stroke-width="2"/><line x1="15" y1="0" x2="15" y2="8" stroke="rgba(255,255,255,0.8)" stroke-width="2"/><line x1="15" y1="22" x2="15" y2="30" stroke="rgba(255,255,255,0.8)" stroke-width="2"/><line x1="0" y1="15" x2="8" y2="15" stroke="rgba(255,255,255,0.8)" stroke-width="2"/><line x1="22" y1="15" x2="30" y2="15" stroke="rgba(255,255,255,0.8)" stroke-width="2"/></svg>') no-repeat center;
            transform: translate(-50%, -50%);
            pointer-events: none;
            transition: transform 0.1s;
            z-index: 10;
        }
        
        #uiOverlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 9;
            /* user-select: none; */
        }
        
        #score, #ammo, #health, #wave {
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        #healthBarBackground {
            width: 200px;
            height: 20px;
            background-color: rgba(50, 50, 50, 0.7);
            border-radius: 10px;
            border: 2px solid #222;
            margin-bottom: 10px;
            overflow: hidden;
        }
        
        #healthBar {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #e74c3c, #f39c12);
            border-radius: 8px;
            transition: width 0.3s;
        }
        
        #gameOverMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 48px;
            color: #e74c3c;
            transform: translate(-50%, -50%);
            display: none;
            text-align: center;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            z-index: 11;
            /* user-select: none; */
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 12;
            /* user-select: none; */
        }
        
        #startScreen h1 {
            font-size: 48px;
            color: #f39c12;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }
        
        #startScreen p {
            font-size: 20px;
            margin: 10px;
            max-width: 600px;
            line-height: 1.5;
        }
        
        #startButton {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(to right, #f39c12, #e74c3c);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        #startButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.5);
        }
        
        #powerUpIndicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 18px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            z-index: 9;
        }
        
        #mobileControls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: none;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 9;
        }
        
        .mobileBtn {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            /* user-select: none; */
            touch-action: manipulation;
        }
        
        #joystick {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 100px;
            height: 100px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: none;
            z-index: 9;
        }
        
        #joystickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            top: 30px;
            left: 30px;
        }
        
        @media (max-width: 768px) {
            #mobileControls {
                display: flex;
            }
            #joystick {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>HAUNTED REALM: GHOST HUNTER</h1>
        <p>You're a paranormal investigator trapped in a haunted dimension. Survive as long as you can against waves of vengeful spirits.</p>
        <p>Collect power-ups to gain temporary advantages against the supernatural forces.</p>
        <p>Controls: WASD to move, Shift to run, Space to jump, Left Click to shoot</p>
        <p>On mobile: Use virtual joystick and buttons</p>
        <button id="startButton">ENTER THE HAUNTED REALM</button>
    </div>
    <div id="crosshair"></div>
    <div id="uiOverlay">
        <div id="score">SCORE: 0</div>
        <div id="wave">WAVE: 1</div>
        <div id="ammo">AMMO: âˆž</div>
        <div id="health">HP: 100</div>
        <div id="healthBarBackground">
            <div id="healthBar"></div>
        </div>
    </div>
    <div id="powerUpIndicator"></div>
    <div id="gameOverMessage">GAME OVER<br><small>Click to Restart</small></div>
    
    <!-- Mobile controls -->
    <div id="mobileControls">
        <div class="mobileBtn" id="jumpBtn">â†‘</div>
        <div class="mobileBtn" id="shootBtn">ðŸ”«</div>
    </div>
    <div id="joystick"><div id="joystickKnob"></div></div>

    <script>
        
        // Game Configuration
        const GAME_CONFIG = {
            initialGhostCount: 5,
            maxGhosts: 15,
            playerMaxHealth: 100,
            ghostMaxHealth: 2,
            moveSpeed: {
                walk: 0.1,
                run: 0.2
            },
            difficulty: {
                initialEnemySpawnRate: 10000, // ms
                enemySpeedIncrease: 0.003, // Incremental speed boost per ghost
                ghostDamage: 10,
                ghostSpeed: 0.05,
                waveIncrease: 2, // How many more ghosts per wave
                waveDuration: 30000 // 30 seconds per wave
            },
            worldBounds: 80,
            powerUps: {
                health: {
                    chance: 0.2,
                    amount: 30,
                    duration: 0,
                    color: 0xff0000
                },
                speed: {
                    chance: 0.3,
                    amount: 1.5,
                    duration: 10000,
                    color: 0x00ff00
                },
                damage: {
                    chance: 0.3,
                    amount: 2,
                    duration: 10000,
                    color: 0xffff00
                },
                invincibility: {
                    chance: 0.2,
                    amount: 0,
                    duration: 8000,
                    color: 0x0000ff
                }
            }
        };

        // Game State Management
        class GameState {
            constructor() {
                this.score = 0;
                this.health = GAME_CONFIG.playerMaxHealth;
                this.ammo = Infinity;
                this.isGameOver = false;
                this.wave = 1;
                this.ghostsKilledThisWave = 0;
                this.powerUps = {
                    speed: { active: false, endTime: 0 },
                    damage: { active: false, endTime: 0 },
                    invincibility: { active: false, endTime: 0 }
                };
                this.startTime = 0;
                this.lastGhostSpawnTime = 0;
            }

            incrementScore() {
                this.score++;
                this.ghostsKilledThisWave++;
                document.getElementById('score').innerText = `SCORE: ${this.score}`;
                
                // Check for wave completion
                if (this.ghostsKilledThisWave >= this.wave * 5) {
                    this.nextWave();
                }
            }

            nextWave() {
                this.wave++;
                this.ghostsKilledThisWave = 0;
                document.getElementById('wave').innerText = `WAVE: ${this.wave}`;
                
                // Show wave notification
                const waveIndicator = document.getElementById('powerUpIndicator');
                waveIndicator.textContent = `WAVE ${this.wave} INCOMING!`;
                waveIndicator.style.display = 'block';
                waveIndicator.style.color = '#f39c12';
                setTimeout(() => {
                    waveIndicator.style.display = 'none';
                }, 2000);
            }

            takeDamage(amount) {
                if (this.powerUps.invincibility.active) return;
                
                this.health = Math.max(0, this.health - amount);
                document.getElementById('health').innerText = `HP: ${this.health}`;
                document.getElementById('healthBar').style.width = `${this.health}%`;

                // Flash screen red when damaged
                document.body.style.backgroundColor = '#400000';
                setTimeout(() => {
                    document.body.style.backgroundColor = '#000';
                }, 100);

                if (this.health <= 0) {
                    this.gameOver();
                }
            }

            heal(amount) {
                this.health = Math.min(GAME_CONFIG.playerMaxHealth, this.health + amount);
                document.getElementById('health').innerText = `HP: ${this.health}`;
                document.getElementById('healthBar').style.width = `${this.health}%`;
                
                // Show healing effect
                document.body.style.backgroundColor = '#004000';
                setTimeout(() => {
                    document.body.style.backgroundColor = '#000';
                }, 100);
            }

            activatePowerUp(type) {
                const powerUp = GAME_CONFIG.powerUps[type];
                this.powerUps[type].active = true;
                this.powerUps[type].endTime = Date.now() + powerUp.duration;
                
                const indicator = document.getElementById('powerUpIndicator');
                indicator.textContent = `${type.toUpperCase()} POWER UP!`;
                indicator.style.display = 'block';
                indicator.style.color = `rgb(${powerUp.color >> 16}, ${(powerUp.color >> 8) & 0xff}, ${powerUp.color & 0xff})`;
                
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 2000);
                
                if (type === 'health') {
                    this.heal(powerUp.amount);
                }
            }

            checkPowerUps() {
                const now = Date.now();
                for (const type in this.powerUps) {
                    if (this.powerUps[type].active && now > this.powerUps[type].endTime) {
                        this.powerUps[type].active = false;
                        
                        if (type !== 'health') {
                            const indicator = document.getElementById('powerUpIndicator');
                            indicator.textContent = `${type.toUpperCase()} POWER UP ENDED`;
                            indicator.style.display = 'block';
                            indicator.style.color = '#ffffff';
                            
                            setTimeout(() => {
                                indicator.style.display = 'none';
                            }, 2000);
                        }
                    }
                }
            }

            gameOver() {
                this.isGameOver = true;
                document.getElementById('gameOverMessage').style.display = 'block';
                document.exitPointerLock();
                
                // Stop all sounds
                if (listener && listener.context) {
                    listener.context.close();
                }
            }

            reset() {
                this.score = 0;
                this.health = GAME_CONFIG.playerMaxHealth;
                this.isGameOver = false;
                this.wave = 1;
                this.ghostsKilledThisWave = 0;
                this.powerUps = {
                    speed: { active: false, endTime: 0 },
                    damage: { active: false, endTime: 0 },
                    invincibility: { active: false, endTime: 0 }
                };
                this.startTime = Date.now();
                this.lastGhostSpawnTime = 0;
                
                document.getElementById('score').innerText = 'SCORE: 0';
                document.getElementById('wave').innerText = 'WAVE: 1';
                document.getElementById('health').innerText = `HP: ${this.health}`;
                document.getElementById('healthBar').style.width = '100%';
                document.getElementById('gameOverMessage').style.display = 'none';
            }
        }

        // Singleton game state
        const gameState = new GameState();

        // Three.js Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Audio setup
        let listener = new THREE.AudioListener();
        camera.add(listener);
        
        // Preload sounds
        const sounds = {
            shoot: new THREE.Audio(listener),
            ghostHit: new THREE.Audio(listener),
            ghostDeath: new THREE.Audio(listener),
            playerHurt: new THREE.Audio(listener),
            powerUp: new THREE.Audio(listener),
            ambient: new THREE.Audio(listener)
        };
        
        const audioLoader = new THREE.AudioLoader();
        
        // Load sounds (using placeholder URLs - replace with actual sound files)
        audioLoader.load('https://assets.mixkit.co/sfx/preview/mixkit-laser-weapon-shot-1681.mp3', function(buffer) {
            sounds.shoot.setBuffer(buffer);
            sounds.shoot.setVolume(0.3);
        });
        
        audioLoader.load('https://assets.mixkit.co/sfx/preview/mixkit-ghostly-scream-2881.mp3', function(buffer) {
            sounds.ghostDeath.setBuffer(buffer);
            sounds.ghostDeath.setVolume(0.5);
        });
        
        audioLoader.load('https://assets.mixkit.co/sfx/preview/mixkit-quick-jump-arcade-game-239.mp3', function(buffer) {
            sounds.ghostHit.setBuffer(buffer);
            sounds.ghostHit.setVolume(0.4);
        });
        
        audioLoader.load('https://assets.mixkit.co/sfx/preview/mixkit-player-jumping-in-a-video-game-2043.mp3', function(buffer) {
            sounds.playerHurt.setBuffer(buffer);
            sounds.playerHurt.setVolume(0.5);
        });
        
        audioLoader.load('https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3', function(buffer) {
            sounds.powerUp.setBuffer(buffer);
            sounds.powerUp.setVolume(0.5);
        });
        
        audioLoader.load('https://assets.mixkit.co/sfx/preview/mixkit-creepy-horror-ambition-532.mp3', function(buffer) {
            sounds.ambient.setBuffer(buffer);
            sounds.ambient.setLoop(true);
            sounds.ambient.setVolume(0.3);
        });

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 0);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);

        // Add flickering light effect
        const pointLight = new THREE.PointLight(0xff6600, 1, 20);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);
        
        function flickerLight() {
            const intensity = 0.5 + Math.random() * 0.5;
            pointLight.intensity = intensity;
            setTimeout(flickerLight, 100 + Math.random() * 900);
        }
        flickerLight();

        // Environment
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(10, 10);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            map: groundTexture,
            color: 0x333333 
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Add some environment objects
        function createEnvironment() {
            // Add some random rocks
            const rockGeometry = new THREE.SphereGeometry(1, 8, 8);
            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x777777 });
            
            for (let i = 0; i < 20; i++) {
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    (Math.random() - 0.5) * GAME_CONFIG.worldBounds * 1.5,
                    0.5,
                    (Math.random() - 0.5) * GAME_CONFIG.worldBounds * 1.5
                );
                rock.scale.set(
                    0.5 + Math.random(),
                    0.3 + Math.random() * 0.7,
                    0.5 + Math.random()
                );
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
            }
            
            // Add some trees
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2);
            const leavesGeometry = new THREE.SphereGeometry(1.5, 8, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            
            for (let i = 0; i < 15; i++) {
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                
                const tree = new THREE.Group();
                trunk.position.y = 1;
                leaves.position.y = 3;
                
                tree.add(trunk);
                tree.add(leaves);
                
                tree.position.set(
                    (Math.random() - 0.5) * GAME_CONFIG.worldBounds * 1.5,
                    0,
                    (Math.random() - 0.5) * GAME_CONFIG.worldBounds * 1.5
                );
                
                tree.castShadow = true;
                tree.receiveShadow = true;
                scene.add(tree);
            }
        }
        
        createEnvironment();

        // Player Movement and Controls
        const controls = {
            moveForward: false,
            moveBackward: false,
            moveLeft: false,
            moveRight: false,
            isRunning: false,
            jump: false,
            touchJump: false,
            touchShoot: false,
            touchMove: { x: 0, y: 0 }
        };

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const raycaster = new THREE.Raycaster();

        // Camera and Player Setup
        camera.position.set(0, 2, 0);
        camera.rotation.order = 'YXZ';

        // Player Movement Physics
        let isOnGround = true;
        const gravity = -0.005;
        let canJump = true;

        // Input Handling
        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'KeyW': controls.moveForward = true; break;
                case 'KeyS': controls.moveBackward = true; break;
                case 'KeyA': controls.moveLeft = true; break;
                case 'KeyD': controls.moveRight = true; break;
                case 'Space': 
                    if (canJump) {
                        velocity.y = 0.15;
                        canJump = false;
                        isOnGround = false;
                    }
                    break;
                case 'ShiftLeft': 
                    controls.isRunning = true;
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': controls.moveForward = false; break;
                case 'KeyS': controls.moveBackward = false; break;
                case 'KeyA': controls.moveLeft = false; break;
                case 'KeyD': controls.moveRight = false; break;
                case 'ShiftLeft': 
                    controls.isRunning = false;
                    break;
            }
        });

        // Mobile touch controls
        document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (canJump) {
                controls.touchJump = true;
                velocity.y = 0.15;
                canJump = false;
                isOnGround = false;
            }
        });
        
        document.getElementById('jumpBtn').addEventListener('touchend', (e) => {
            e.preventDefault();
            controls.touchJump = false;
        });
        
        document.getElementById('shootBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            controls.touchShoot = true;
            shoot();
        });
        
        document.getElementById('shootBtn').addEventListener('touchend', (e) => {
            e.preventDefault();
            controls.touchShoot = false;
        });
        
        // Joystick for mobile
        const joystick = document.getElementById('joystick');
        const joystickKnob = document.getElementById('joystickKnob');
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        let joystickX = 0;
        let joystickY = 0;
        
        joystick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = joystick.getBoundingClientRect();
            joystickStartX = rect.left + rect.width / 2;
            joystickStartY = rect.top + rect.height / 2;
            joystickX = touch.clientX - joystickStartX;
            joystickY = touch.clientY - joystickStartY;
            
            const distance = Math.sqrt(joystickX * joystickX + joystickY * joystickY);
            if (distance > 50) {
                joystickX = joystickX * 50 / distance;
                joystickY = joystickY * 50 / distance;
            }
            
            joystickKnob.style.transform = `translate(${joystickX}px, ${joystickY}px)`;
            joystickActive = true;
            
            // Convert joystick position to movement controls
            controls.touchMove.x = joystickX / 50;
            controls.touchMove.y = -joystickY / 50;
        });
        
        document.addEventListener('touchmove', (e) => {
            if (!joystickActive) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            joystickX = touch.clientX - joystickStartX;
            joystickY = touch.clientY - joystickStartY;
            
            const distance = Math.sqrt(joystickX * joystickX + joystickY * joystickY);
            if (distance > 50) {
                joystickX = joystickX * 50 / distance;
                joystickY = joystickY * 50 / distance;
            }
            
            joystickKnob.style.transform = `translate(${joystickX}px, ${joystickY}px)`;
            
            // Convert joystick position to movement controls
            controls.touchMove.x = joystickX / 50;
            controls.touchMove.y = -joystickY / 50;
        });
        
        document.addEventListener('touchend', (e) => {
            if (!joystickActive) return;
            e.preventDefault();
            
            joystickKnob.style.transform = 'translate(0, 0)';
            joystickActive = false;
            controls.touchMove.x = 0;
            controls.touchMove.y = 0;
        });

        // Mouse Look
        let isPointerLocked = false;
        let mouseX = 0, mouseY = 0;

        document.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                mouseX -= e.movementX * 0.002;
                mouseY -= e.movementY * 0.002;
                
                // Limit vertical rotation
                mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
                
                // Crosshair effect
                const crosshair = document.getElementById("crosshair");
                crosshair.style.transform = `translate(-50%, -50%) scale(1.2)`;
                setTimeout(() => {
                    crosshair.style.transform = `translate(-50%, -50%) scale(1)`;
                }, 100);
            }
        });

        // Shooting Mechanic
        function shoot() {
            if (!isPointerLocked) return;
            
            const shootRaycaster = new THREE.Raycaster();
            shootRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            const intersects = shootRaycaster.intersectObjects(scene.children, true);
            
            // Play shoot sound
            if (sounds.shoot.isPlaying) sounds.shoot.stop();
            sounds.shoot.play();
            
            // Visual shooting effect (muzzle flash)
            const muzzleFlash = new THREE.PointLight(0xff6600, 5, 2);
            muzzleFlash.position.copy(camera.position);
            scene.add(muzzleFlash);
            
            // Bullet tracer
            const bulletDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const bulletEnd = bulletDirection.clone().multiplyScalar(100).add(camera.position);
            
            const bulletGeometry = new THREE.BufferGeometry().setFromPoints([
                camera.position,
                bulletEnd
            ]);
            
            const bulletMaterial = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 });
            const bullet = new THREE.Line(bulletGeometry, bulletMaterial);
            scene.add(bullet);
            
            // Remove effects after short time
            setTimeout(() => {
                scene.remove(muzzleFlash);
                scene.remove(bullet);
            }, 200);
            
            // Check for ghost hits
            ghosts.forEach((ghost, index) => {
                const ghostIntersects = shootRaycaster.intersectObject(ghost, true);
                
                if (ghostIntersects.length > 0) {
                    ghost.health--;
                    
                    // Play hit sound
                    if (sounds.ghostHit.isPlaying) sounds.ghostHit.stop();
                    sounds.ghostHit.play();
                    
                    // Visual hit effect
                    const hitPosition = ghostIntersects[0].point;
                    const hitGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                    const hitMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xff0000,
                        transparent: true,
                        opacity: 0.7
                    });
                    const hitEffect = new THREE.Mesh(hitGeometry, hitMaterial);
                    hitEffect.position.copy(hitPosition);
                    scene.add(hitEffect);
                    
                    setTimeout(() => {
                        scene.remove(hitEffect);
                    }, 200);
                    
                    if (ghost.health <= 0) {
                        // Play death sound
                        if (sounds.ghostDeath.isPlaying) sounds.ghostDeath.stop();
                        sounds.ghostDeath.play();
                        
                        // Death effect
                        const deathEffect = new THREE.Group();
                        for (let i = 0; i < 5; i++) {
                            const particleGeometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.2, 4, 4);
                            const particleMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0xffffff,
                                transparent: true,
                                opacity: 0.7
                            });
                            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                            particle.position.copy(ghost.position);
                            particle.userData.velocity = new THREE.Vector3(
                                (Math.random() - 0.5) * 0.2,
                                Math.random() * 0.2,
                                (Math.random() - 0.5) * 0.2
                            );
                            deathEffect.add(particle);
                        }
                        scene.add(deathEffect);
                        
                        setTimeout(() => {
                            scene.remove(deathEffect);
                        }, 1000);
                        
                        scene.remove(ghost);
                        ghosts.splice(index, 1);
                        gameState.incrementScore();
                        
                        // Chance to spawn power-up
                        if (Math.random() < 0.3) {
                            spawnPowerUp(hitPosition);
                        }
                        
                        createGhost();
                    }
                }
            });
        }
        
        document.addEventListener('click', () => {
            if (!isPointerLocked) {
                renderer.domElement.requestPointerLock();
                isPointerLocked = true;
                document.getElementById('startScreen').style.display = 'none';
                
                // Start ambient sound
                if (sounds.ambient) {
                    sounds.ambient.play();
                }
                
                return;
            }
            
            shoot();
        });

        // Power-up system
        function spawnPowerUp(position) {
            const powerUpTypes = Object.keys(GAME_CONFIG.powerUps);
            const randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
            const powerUpConfig = GAME_CONFIG.powerUps[randomType];
            
            const powerUpGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const powerUpMaterial = new THREE.MeshStandardMaterial({ 
                color: powerUpConfig.color,
                emissive: powerUpConfig.color,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.8
            });
            
            const powerUp = new THREE.Mesh(powerUpGeometry, powerUpMaterial);
            powerUp.position.copy(position);
            powerUp.position.y = 1;
            powerUp.userData.type = randomType;
            
            // Add pulsing animation
            powerUp.userData.pulseSpeed = 0.05 + Math.random() * 0.05;
            powerUp.userData.pulseSize = 0.5;
            
            scene.add(powerUp);
            
            // Remove after 10 seconds if not collected
            setTimeout(() => {
                if (scene.children.includes(powerUp)) {
                    scene.remove(powerUp);
                }
            }, 10000);
            
            return powerUp;
        }

        // Pointer Lock Events
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        });

        // Game Over / Restart
        document.getElementById('gameOverMessage').addEventListener('click', () => {
            if (gameState.isGameOver) {
                // Clear existing ghosts
                ghosts.forEach(ghost => scene.remove(ghost));
                ghosts.length = 0;
                
                // Clear power-ups
                scene.children.forEach(child => {
                    if (child.userData && child.userData.type) {
                        scene.remove(child);
                    }
                });
                
                // Respawn initial ghosts
                for (let i = 0; i < GAME_CONFIG.initialGhostCount; i++) {
                    createGhost();
                }
                
                gameState.reset();
                camera.position.set(0, 2, 0);
                renderer.domElement.requestPointerLock();
                
                // Restart ambient sound
                if (sounds.ambient) {
                    sounds.ambient.play();
                }
            }
        });
        
        // Start button
        document.getElementById('startButton').addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
            isPointerLocked = true;
            document.getElementById('startScreen').style.display = 'none';
            
            // Start ambient sound
            if (sounds.ambient) {
                sounds.ambient.play();
            }
        });

        // Ghost Management
        const ghosts = [];
        const ghostGeometry = new THREE.SphereGeometry(1, 8, 8);
        const ghostMaterial = new THREE.MeshStandardMaterial({
            color: 0xdddddd,
            transparent: true,
            opacity: 0.7,
            emissive: 0x888888,
            emissiveIntensity: 0.3
        });

        function createGhost() {
            if (ghosts.length >= GAME_CONFIG.initialGhostCount + gameState.wave * GAME_CONFIG.difficulty.waveIncrease) return;
            
            const ghost = new THREE.Mesh(ghostGeometry, ghostMaterial.clone());
            ghost.castShadow = true;
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.3, 0.2, -0.7);
            ghost.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.3, 0.2, -0.7);
            ghost.add(rightEye);
            
            ghost.scale.set(0.8, 0.8, 0.8);
            ghost.position.set(
                (Math.random() - 0.5) * GAME_CONFIG.worldBounds,
                Math.random() * 2 + 1,
                (Math.random() - 0.5) * GAME_CONFIG.worldBounds
            );
            
            const speedMultiplier = 1 + (gameState.wave * 0.1);
            ghost.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * GAME_CONFIG.difficulty.ghostSpeed * speedMultiplier,
                (Math.random() - 0.5) * 0.02,
                (Math.random() - 0.5) * GAME_CONFIG.difficulty.ghostSpeed * speedMultiplier
            );
            
            ghost.health = GAME_CONFIG.ghostMaxHealth;
            ghost.damage = GAME_CONFIG.difficulty.ghostDamage;
            
            // Add floating animation
            ghost.userData.floatSpeed = 0.01 + Math.random() * 0.02;
            ghost.userData.floatHeight = ghost.position.y;
            
            scene.add(ghost);
            ghosts.push(ghost);
        }

        // Initial ghost spawn
        for (let i = 0; i < GAME_CONFIG.initialGhostCount; i++) {
            createGhost();
        }

        // Game Loop
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            const deltaTime = time - lastTime;
            lastTime = time;
            
            // Update camera rotation
            camera.rotation.y = mouseX;
            camera.rotation.x = mouseY;

            // Player Movement - FIXED VERSION
            direction.set(0, 0, 0);
            let playerSpeed = controls.isRunning ? 
                GAME_CONFIG.moveSpeed.run : 
                GAME_CONFIG.moveSpeed.walk;
                
            // Apply speed power-up
            if (gameState.powerUps.speed.active) {
                playerSpeed *= GAME_CONFIG.powerUps.speed.amount;
            }
            
            // Get forward and right vectors based on camera rotation
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            
            // Keyboard controls - now relative to camera direction
            if (controls.moveForward) direction.add(forward);
            if (controls.moveBackward) direction.add(forward.clone().negate());
            if (controls.moveLeft) direction.add(right.clone().negate());
            if (controls.moveRight) direction.add(right);
            
            // Mobile touch controls
            if (controls.touchMove.x !== 0 || controls.touchMove.y !== 0) {
                direction.add(right.clone().multiplyScalar(controls.touchMove.x));
                direction.add(forward.clone().multiplyScalar(controls.touchMove.y));
            }

            // Normalize direction if moving in multiple directions
            if (direction.length() > 0) {
                direction.normalize();
            }

            // Apply movement
            velocity.x = direction.x * playerSpeed;
            velocity.z = direction.z * playerSpeed;

            // Apply gravity
            velocity.y += gravity;

            // Ground collision
            if (camera.position.y <= 2) {
                camera.position.y = 2;
                velocity.y = 0;
                canJump = true;
                isOnGround = true;
            } else {
                isOnGround = false;
            }

            // Apply velocity
            camera.position.add(velocity);

            // World bounds
            camera.position.x = Math.max(-GAME_CONFIG.worldBounds, 
                Math.min(GAME_CONFIG.worldBounds, camera.position.x));
            camera.position.z = Math.max(-GAME_CONFIG.worldBounds, 
                Math.min(GAME_CONFIG.worldBounds, camera.position.z));

            // Ghost movement and player interaction
            ghosts.forEach((ghost, index) => {
                // Ghost floating animation
                ghost.position.y = ghost.userData.floatHeight + Math.sin(time * ghost.userData.floatSpeed) * 0.5;
                
                // Ghost movement
                ghost.position.add(ghost.velocity);
                
                // Make ghosts face the player but only on Y axis
                ghost.lookAt(camera.position);
                ghost.rotation.x = 0;
                ghost.rotation.z = 0;

                // Boundary checking for ghosts
                if (Math.abs(ghost.position.x) > GAME_CONFIG.worldBounds) {
                    ghost.velocity.x *= -1;
                    ghost.position.x = Math.sign(ghost.position.x) * GAME_CONFIG.worldBounds * 0.99;
                }
                if (Math.abs(ghost.position.z) > GAME_CONFIG.worldBounds) {
                    ghost.velocity.z *= -1;
                    ghost.position.z = Math.sign(ghost.position.z) * GAME_CONFIG.worldBounds * 0.99;
                }
                
                // Player-ghost collision detection
                const distance = camera.position.distanceTo(ghost.position);
                if (distance < 2) {
                    // Damage player on close contact
                    gameState.takeDamage(ghost.damage * (gameState.powerUps.invincibility.active ? 0 : 1));
                    
                    // Push player back
                    const pushDirection = new THREE.Vector3().subVectors(camera.position, ghost.position).normalize();
                    velocity.x = pushDirection.x * 0.2;
                    velocity.z = pushDirection.z * 0.2;
                    velocity.y = 0.1;
                    
                    // Play hurt sound
                    if (sounds.playerHurt.isPlaying) sounds.playerHurt.stop();
                    sounds.playerHurt.play();
                }
                
                // Ghost-ghost collision avoidance
                ghosts.forEach(otherGhost => {
                    if (ghost !== otherGhost) {
                        const ghostDistance = ghost.position.distanceTo(otherGhost.position);
                        if (ghostDistance < 3) {
                            const avoidDirection = new THREE.Vector3().subVectors(ghost.position, otherGhost.position).normalize();
                            ghost.velocity.x += avoidDirection.x * 0.01;
                            ghost.velocity.z += avoidDirection.z * 0.01;
                        }
                    }
                });
            });
            
            // Power-up collection check
            scene.children.forEach(child => {
                if (child.userData && child.userData.type) {
                    const distance = camera.position.distanceTo(child.position);
                    if (distance < 1.5) {
                        gameState.activatePowerUp(child.userData.type);
                        
                        // Play power-up sound
                        if (sounds.powerUp.isPlaying) sounds.powerUp.stop();
                        sounds.powerUp.play();
                        
                        // Remove power-up
                        scene.remove(child);
                    } else {
                        // Animate power-up
                        child.rotation.y += 0.02;
                        child.scale.setScalar(child.userData.pulseSize + Math.sin(time * child.userData.pulseSpeed) * 0.2);
                    }
                }
            });
            
            // Check power-up timers
            gameState.checkPowerUps();
            
            // Spawn ghosts based on wave progression
            const timeSinceLastSpawn = time - gameState.lastGhostSpawnTime;
            if (ghosts.length < GAME_CONFIG.initialGhostCount + gameState.wave * GAME_CONFIG.difficulty.waveIncrease && 
                timeSinceLastSpawn > GAME_CONFIG.difficulty.initialEnemySpawnRate / (1 + gameState.wave * 0.2)) {
                createGhost();
                gameState.lastGhostSpawnTime = time;
            }
            
            // Render the scene
            renderer.render(scene, camera);
        }

        // Start the game loop
        animate();

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Fullscreen toggle
        document.addEventListener('keydown', (e) => {
            if (e.key === 'f') {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log(`Error attempting to enable fullscreen: ${err.message}`);
                    });
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            }
        });
        
        // Prevent right-click menu
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
    </script>
</body>
</html>